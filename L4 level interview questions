
Linux L4 Real-time interview questions and answers. Part-1

1. A server becomes unresponsive тАФ whatтАЩs your step-by-step approach to troubleshoot?
Check basic connectivity:
ping <server_ip>
ssh <server_ip>

If ping works but SSH fails:

Check CPU/memory:
top | head -20
Or, if SSH unresponsive тЖТ access via console or IPMI.

Check I/O wait and load:
iostat -xm 5
vmstat 5
uptime

Check for disk full (common cause):
df -h
du -sh /* 2>/dev/null | sort -rh | head

Check kernel messages:
dmesg | tail -50

If system is hung (high load, low I/O):

Find blocking process:
ps -eo pid,stat,cmd | grep 'D'
тАЬDтАЭ = Uninterruptible sleep (usually I/O wait).

2. How do you identify a process causing high load but not high CPU usage?

That usually indicates I/O wait or blocked processes.

Check:
vmstat 1 5

Look for high wa (I/O wait) value.
iotop -ao

Shows which process is performing heavy I/O.
If itтАЩs a disk issue:
sar -d 1 5
or
iostat -x 1 5

3. How do you debug high memory usage or memory leaks in Linux?

Check memory summary:
free -m

Find top memory consumers:
ps aux --sort=-%mem | head

If memory is full but swap is active тЖТ possible leak.

For deeper kernel memory leak analysis:
slabtop
cat /proc/meminfo

Use smem or pmap <pid> to check per-process memory footprint.

4. How do you handle a situation where /var or /tmp is 100% full?
Identify large files:
du -sh /var/* | sort -rh | head
Common culprits: logs, cores, temp files.
journalctl --vacuum-time=7d
rm -rf /tmp/*
Check for deleted but still-open files:
lsof | grep deleted
Truncate large logs safely:
 > /var/log/filename.log

Prevent recurrence тАФ add logrotate or move /var to a separate partition.

5. What is the difference between a zombie and an orphan process?
Zombie Process рдХреНрдпрд╛ рд╣реЛрддрд╛ рд╣реИ?
тЬФ Zombie Process = Process рдиреЗ рдЕрдкрдирд╛ рдХрд╛рдо рдкреВрд░рд╛ рдХрд░ рд▓рд┐рдпрд╛, Exit рднреА рдХрд░ рдЧрдпрд╛тАж рд▓реЗрдХрд┐рди рдлрд┐рд░ рднреА Process Table рдореЗрдВ 
рдЙрд╕рдХрд╛ entry рдмрдЪрд╛ рд╣реБрдЖ рд╣реИред
рдРрд╕рд╛ рдХреНрдпреЛрдВ рд╣реЛрддрд╛ рд╣реИ?
Child process рдЦрддреНрдо рд╣реЛрдХрд░ exit status (return code) parent рдХреЛ рднреЗрдЬрддрд╛ рд╣реИред
Parent рдХреЛ рдпрд╣ status wait() / waitpid() рд╕реЗ рдкрдврд╝рдирд╛ рдЪрд╛рд╣рд┐рдПред
рдЕрдЧрд░ parent рдиреЗ status рдирд╣реАрдВ рдкрдврд╝рд╛ тЖТ child рдорд░ рдЪреБрдХрд╛ рд╣реИ рд▓реЗрдХрд┐рди рдЙрд╕рдХреА entry тАЬрдЕрдЯрдХреАтАЭ рд░рд╣рддреА рд╣реИ тЖТ рд╡рд╣ Zombie рдмрди рдЬрд╛рддрд╛ рд╣реИред
ЁЯУМ Zombie рдХреА рдЦрд╛рд╕ рдмрд╛рдд
Zombie run рдирд╣реАрдВ рдХрд░рддрд╛, CPU use рдирд╣реАрдВ рдХрд░рддрд╛
рд╕рд┐рд░реНрдл process table рдореЗрдВ рдЬрдЧрд╣ рдШреЗрд░рддрд╛ рд╣реИ
ЁЯУМ Zombie рдХреЛ рд╣рдЯрд╛рдиреЗ рдХрд╛ рддрд░реАрдХрд╛
рдЖрдк zombie рдХреЛ kill рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ (рдХреНрдпреЛрдВрдХрд┐ рд╡рд╣ already dead рд╣реИ)
рдХреЗрд╡рд▓ parent process рдХреЛ kill рдпрд╛ restart рдХрд░рдиреЗ рд╕реЗ zombie рд╣рдЯрддрд╛ рд╣реИ
(рдлрд┐рд░ systemd рдЙрд╕реЗ рд╕рд╛рдлрд╝ рдХрд░ рджреЗрддрд╛ рд╣реИ)
тЬЕ 2я╕ПтГг Detailed output рд╕реЗ parent рдкрддрд╛ рдХрд░реЗрдВ
ps -eo pid,ppid,state,cmd | grep Z
ps -eo pid,ppid,state,cmd | grep Z
рдЖрдкрдХреЛ рдРрд╕рд╛ рджрд┐рдЦрд╛рдИ рджреЗрдЧрд╛:
4521  4500  Z     [mychild] <defunct>
рдпрд╣реА parent рд╣реИ тЖТ PID 4500
тЪЩя╕П Parent рдХреЛ kill/restart рдХреИрд╕реЗ рдХрд░реЗрдВ?
рдЕрдЧрд░ рдЖрдк parent рдХреЛ kill рдХрд░рдирд╛ рдЪрд╛рд╣реЗрдВ:
kill -9 <PPID>
рдпрд╛ gracefully:
kill -15 <PPID>


 тЬФ Orphan Process = Parent process рдорд░ рдЧрдпрд╛, рд▓реЗрдХрд┐рди child process 
 рдЕрднреА рднреА рдЪрд▓ рд░рд╣рд╛ рд╣реИред рдЬрдм рдРрд╕рд╛ рд╣реЛрддрд╛ рд╣реИ рддреЛ Linux рдореЗрдВ: ЁЯСЙ Child process рдХреЛ systemd (PID 1) 
 рдЕрдкрдирд╛ parent рдмрдирд╛ рд▓реЗрддрд╛ рд╣реИ рдЗрд╕реЗ рдХрд╣рддреЗ рд╣реИрдВ re-parentingред рдЗрд╕рд▓рд┐рдП orphan process dangerous рдирд╣реАрдВ рд╣реЛрддреЗред systemd рдРрд╕реЗ 
processes рдХреЛ efficiently manage рдХрд░рддрд╛ рд╣реИред

6. How do you trace which process deleted or modified a file?
auditctl -w /path/to/file -p war -k filewatch
ausearch -k filewatch
Or with inotify:
inotifywait -m /path/to/dir

For real-time event auditing, L4s often integrate with SELinux/Auditd rules.

7. How do you analyze system performance using sar or sysstat?
sar helps analyze historic CPU, memory, and I/O metrics.

sar -u 5 5     # CPU usage
sar -r 5 5     # Memory usage
sar -d 5 5     # Disk I/O
sar -n DEV 5 5   # Network

8. Explain how youтАЩd troubleshoot a slow NFS mount.
Check network latency:
ping nfs-server
traceroute nfs-server
Check NFS mount options:
mount | grep nfs
Ensure using noatime, hard, tcp, rsize/wsize=65536.

Test read/write:

dd if=/dev/zero of=/mnt/test bs=1M count=100 oflag=direct

Check NFS stats:

nfsstat -s -c
If slow, analyze server-side logs: /var/log/messages
